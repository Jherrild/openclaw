# Interrupt Service - Product Requirements Document (PRD)

## 1. Vision

A centralized, source-agnostic daemon for managing asynchronous interrupts. It decouples **Event Detection** (HA, Email, RSS) from **Notification Delivery** (System Event, Sub-agent) and provides a single source of truth for all interrupt rules, rate limits, and dispatch logic.

This service is the **sole owner** of interrupt pipeline state. Collectors are dumb. Magnus (and users) manage everything through one CLI and one HTTP API.

## 2. Core Responsibilities

1. **Rule Management:** Full CRUD for persistent and one-off interrupt rules.
2. **Event Matching:** Source-agnostic rule matching with pluggable condition logic and wildcard support.
3. **Pipeline Engine:** Dual independent pipelines (message + subagent) with batching, rate limiting, and circuit breakers.
4. **Dispatch:** Message pipeline → `openclaw system event`. Subagent pipeline → `openclaw agent --local`.
5. **Validation:** Pluggable source validators (HA entity check, channel check, state check).
6. **One-Off Lifecycle:** Auto-consume after successful dispatch; restore on failure.
7. **Settings Management:** Runtime-configurable pipeline settings with hot reload.

## 3. Rule Schema

```json
{
  "id": "rule-unique-id",
  "source": "ha.state_change",
  "condition": { "entity_id": "binary_sensor.front_door_motion", "state": "on" },
  "action": "subagent",
  "label": "Front door motion",
  "message": "Motion at front door: {{new_state}}",
  "instruction": "Check if anyone is expected; if not, announce security alert via follow-and-speak",
  "channel": "telegram",
  "session_id": "main",
  "one_off": false,
  "enabled": true,
  "created": "2026-02-08T22:00:00.000Z"
}
```

### Field Reference

| Field | Required | Default | Description |
|-------|----------|---------|-------------|
| `id` | Yes | — | Unique rule identifier (auto-generated by CLI, or user-specified via API) |
| `source` | Yes | — | Event source type: `ha.state_change`, `email`, `system`, `generic`, etc. |
| `condition` | No | `{}` | Key-value pairs matched against event data. Supports `*` glob wildcards. |
| `action` | No | `subagent` | Dispatch type: `message` (direct system event) or `subagent` (spawn analysis agent) |
| `label` | No | `id` | Human-readable name for logging and listing |
| `message` | No | auto | Template with `{{key}}` placeholders interpolated from event data |
| `instruction` | No | `null` | Custom context/instructions passed to the sub-agent prompt |
| `channel` | No | `default` | Notification channel. `"default"` resolves to `settings.default_channel` at dispatch time |
| `session_id` | No | `main` | Target session ID for dispatch |
| `one_off` | No | `false` | If `true`, rule is consumed after successful dispatch |
| `enabled` | No | `true` | Set `false` to disable without deleting |
| `created` | No | auto | ISO timestamp of rule creation |

## 4. Dual-Pipeline Engine

### Architecture
Two completely independent pipelines, selected by the rule's `action` field:

| Pipeline | Trigger Type | Behavior | Default Batch Window | Default Rate Limit |
|----------|-------------|----------|---------------------|-------------------|
| **Message** | `message` | Direct `openclaw system event --mode now` into Main Session | 2s | 10/min |
| **Subagent** | `subagent` | Spawn `openclaw agent --local` to analyze and decide | 5s | 4/min |

### Per-Pipeline State
Each pipeline independently maintains:
- **Batch Queue:** Triggers collected within the batch window → flushed as single dispatch.
- **Rate Limiter:** Rolling-window counter. Dispatches exceeding `rate_limit_max` per `rate_limit_window_ms` are dropped.
- **Circuit Breaker:** Opens when rate limit is exceeded. Auto-closes when window resets. While open, all dispatches are dropped with warning log.

Pipelines never cross — message and subagent interrupts are batched, rate-limited, and dispatched completely independently.

### Message Dispatch
For each trigger in the batch:
```bash
openclaw system event --text "<interpolated message>" --mode now
```

### Subagent Dispatch
Triggers are **grouped by resolved `channel` + `session_id`** for efficient batching. One sub-agent per group.

The sub-agent prompt must be **rich** — not just echoing the interrupt:
```
You are a home automation sub-agent handling an interrupt.

INTERRUPT DETAILS:
<summaries with instructions>

YOUR GOAL:
1. Analyze the interrupt and any provided instructions.
2. Check relevant logs (e.g. presence-log.jsonl) or use 'GetLiveContext' if needed to verify conditions.
3. DECIDE: Does the user need to be notified?

IF NOTIFICATION IS NEEDED:
- Send a message using: openclaw message send --channel <channel> --message "Your message here"

IF NO NOTIFICATION IS NEEDED:
- Exit silently.

CRITICAL:
- Be concise.
- Only notify if the condition is truly met and important.
- Do NOT simply echo the interrupt; add value or verify context.
```

## 5. One-Off Lifecycle

One-off rules provide "fire once" behavior with failure safety:

1. **Registration:** Rule added with `one_off: true`.
2. **Match:** Event matches rule → rule marked `_pending: true` in the store (prevents re-triggering during async dispatch).
3. **Dispatch success:** Rule permanently removed from store.
4. **Dispatch failure:** `_pending` flag cleared → rule is restored for future re-triggering.

This ensures one-off rules are never lost due to transient failures.

## 6. Validation Framework

### Source Validators
Pluggable validator scripts configured in `settings.json`:
```json
{
  "validators": {
    "ha.state_change": "/path/to/skills/home-presence/validate-entity.js"
  }
}
```

### Validation Flow
1. **Rule registration** → service looks up `validators[rule.source]`.
2. **If no validator:** Rule accepted (generic/untyped sources).
3. **If validator exists:** Script executed with the relevant field (e.g., `entity_id`).
4. **If validation fails:** Rule rejected with error message. No ghost interrupts.

### HA-Specific Validation (`ha.state_change`)
- **Entity existence:** Checked via HA REST API (`GET /api/states`). On mismatch, returns Levenshtein-based suggestions.
- **State plausibility:** Checked against known domain states (e.g., `binary_sensor` → `on`/`off`).
- **Wildcards:** Patterns containing `*` skip entity existence checks but still validate state.
- **Virtual entities:** `magnus.*` prefix bypasses existence checks entirely.

### Channel Validation
- Validated against `openclaw channels list --json`.
- `"default"` is always valid (resolves at dispatch time).

### Skip Flag
`--skip-validation` on CLI bypasses all checks (for when HA is down, future entities, etc.).

## 7. HTTP API

The daemon listens on `127.0.0.1:<port>` (default 7600).

| Method | Path | Description |
|--------|------|-------------|
| `POST` | `/trigger` | Submit an event from a collector |
| `POST` | `/rules` | Add or update a rule (with validation) |
| `DELETE` | `/rules/:id` | Remove a rule by ID |
| `GET` | `/rules` | List all rules (persistent + one-off) |
| `GET` | `/rules/ha-entities` | List entity_ids from active `ha.state_change` rules (for ha-bridge watchlist) |
| `GET` | `/stats` | Pipeline statistics (queue depth, rate limit state, circuit breaker status) |
| `GET` | `/health` | Liveness check (`{ status: "ok", pid: <pid> }`) |
| `POST` | `/reload` | Reload rules from disk (with re-validation) |
| `GET` | `/settings` | Get current settings |
| `PUT` | `/settings` | Update settings (JSON merge patch) |

### POST /trigger
```json
{
  "source": "ha.state_change",
  "data": { "entity_id": "binary_sensor.motion", "new_state": "on", "old_state": "off" },
  "level": "info"
}
```
- `source` (required): Event source identifier.
- `data` (optional): Arbitrary event payload — matched against rule conditions.
- `level` (optional): `info` | `warn` | `alert`. Default: `info`.
- **Default action:** `warn`/`alert` with no matching rule → auto-queued (message for warn, subagent for alert). `info` with no match → silently ignored.

### POST /rules
```json
{
  "id": "motion-alert",
  "source": "ha.state_change",
  "condition": { "entity_id": "binary_sensor.front_door_motion", "state": "on" },
  "action": "message",
  "message": "Motion at front door: {{new_state}}",
  "one_off": false
}
```
Returns `200` with `{ status: "added", validated: true }` or `422` with validation error.

## 8. CLI (`interrupt-cli.js`)

The CLI is the primary interface for Magnus and users. All commands talk to the daemon via HTTP.

### Commands

```
interrupt-cli.js add --source <src> [options]      Add a rule (persistent by default)
interrupt-cli.js remove <id>                        Remove a rule by ID
interrupt-cli.js list                               List all rules
interrupt-cli.js trigger --source <src> [options]   Fire an event (for collectors)
interrupt-cli.js settings get                       Show pipeline settings
interrupt-cli.js settings set '<json-patch>'        Update settings at runtime
interrupt-cli.js stats                              Pipeline statistics
interrupt-cli.js health                             Liveness check
interrupt-cli.js reload                             Reload rules from disk
```

### `add` Options

| Flag | Description |
|------|-------------|
| `--source <src>` | (required) Source type |
| `--condition <json>` | Match conditions (JSON string) |
| `--action <type>` | `message` or `subagent` (default: `subagent`) |
| `--label <text>` | Human-readable label |
| `--message <text>` | Message template (supports `{{key}}` interpolation) |
| `--instruction <text>` | Custom instructions for sub-agent |
| `--channel <name>` | Notification channel (default: `"default"`) |
| `--session-id <id>` | Target session (default: `"main"`) |
| `--one-off` | Make this a one-off rule (auto-consumed after dispatch) |
| `--skip-validation` | Bypass all validation checks |

### `trigger` Options

| Flag | Description |
|------|-------------|
| `--source <src>` | (required) Event source |
| `--data <json>` | Event payload (JSON string) |
| `--level <level>` | `info`, `warn`, or `alert` (default: `info`) |
| `--message <text>` | Shorthand — sets `data.message` |

### Examples
```bash
# Add a persistent HA interrupt with instructions
interrupt-cli.js add --source ha.state_change \
  --condition '{"entity_id":"binary_sensor.front_door_motion","state":"on"}' \
  --label "Front door motion" \
  --instruction "Check if anyone is expected; if not, announce security alert"

# Add a one-off interrupt
interrupt-cli.js add --source ha.state_change \
  --condition '{"entity_id":"person.jesten","state":"home"}' \
  --label "Jesten arrived" --one-off \
  --instruction "Greet Jesten warmly via follow-and-speak"

# Trigger from a collector
interrupt-cli.js trigger --source ha.state_change \
  --data '{"entity_id":"binary_sensor.motion","new_state":"on","old_state":"off"}'

# System alert
interrupt-cli.js trigger --source system --message "Disk usage above 90%" --level warn

# List all rules
interrupt-cli.js list

# Remove a rule
interrupt-cli.js remove motion-alert

# View/update settings
interrupt-cli.js settings get
interrupt-cli.js settings set '{"message":{"batch_window_ms":1000}}'
```

## 9. Configuration

### `settings.json`
```json
{
  "port": 7600,
  "message":  { "batch_window_ms": 2000, "rate_limit_max": 10, "rate_limit_window_ms": 60000 },
  "subagent": { "batch_window_ms": 5000, "rate_limit_max": 4,  "rate_limit_window_ms": 60000 },
  "log_limit": 1000,
  "default_channel": "telegram",
  "validators": {
    "ha.state_change": "/home/jherrild/.openclaw/workspace/skills/home-presence/validate-entity.js"
  },
  "collectors": {
    "ha.state_change": "http://127.0.0.1:7601"
  }
}
```

### `interrupt-rules.json`
Array of rule objects (see Rule Schema above). This is the **single source of truth** for all interrupt rules across all sources.

### Hot Reload
The daemon watches `interrupt-rules.json` and `settings.json` for changes (configurable poll interval via `file_poll_ms`). Changes take effect without restart.

## 10. Collector Push Protocol

When a rule is added, removed, or reloaded, the interrupt service pushes the updated watchlist to the relevant collector(s). This ensures collectors react immediately — no polling delay.

### Configuration
```json
{
  "collectors": {
    "ha.state_change": "http://127.0.0.1:7601"
  }
}
```
Map of `source` → collector base URL. Sources without a collector entry are accepted without push.

### Push Behavior

| Event | Push Target | On Failure |
|-------|-------------|------------|
| **Rule added** | `POST <collector>/watchlist` | **Roll back** rule, return `503 COLLECTOR_UNAVAILABLE` |
| **Rule removed** | `POST <collector>/watchlist` | Rule deleted, response includes `warning` field |
| **Rules reloaded** | All configured collectors | Best-effort, failures logged |

### Watchlist Payload
```json
POST /watchlist
{ "entities": ["person.april_jane", "magnus.voice_command"] }

Response: 200
{ "status": "ok", "entities": 2 }
```

### Error Response (collector down)
```json
HTTP 503
{
  "error": "Collector unavailable: connect ECONNREFUSED 127.0.0.1:7601",
  "code": "COLLECTOR_UNAVAILABLE",
  "rule": "rule-id"
}
```

### Collector Interface
Any collector that supports push notifications must expose:
- `POST /watchlist` — accepts `{ "entities": [...] }`, updates internal watchlist, returns `200`.
- `GET /health` *(recommended)* — returns `200` with status info.

## 11. Migration Plan

### From Old System (`interrupt-manager.js` in home-presence)

1. **Rules migration:** Convert `persistent-interrupts.json` and `one-off-interrupts.json` entries into `interrupt-rules.json` format (add `source: "ha.state_change"`, map `entity_id`/`state` into `condition` object, add `one_off` flag).
2. **Settings migration:** Merge `interrupt-settings.json` into `settings.json` (add `default_channel`, `validators`).
3. **CLI migration:** Replace `register-interrupt.js` calls with `interrupt-cli.js` equivalents.
4. **Bridge migration:** `ha-bridge.js` drops `InterruptManager` import, uses HTTP client to POST events and sync watchlist (already done in current branch).
5. **Deprecation:** Remove `interrupt-manager.js`, old interrupt JSON files, and `register-interrupt.js` from home-presence.

## 12. Challenges & Solutions

### Challenge 1: Tight Coupling to Home Assistant
**Problem:** The old system's `evaluate(entityId, oldState, newState)` only understood HA events.
**Solution:** Generic `POST /trigger` with `source` + `data`. Pluggable matchers switch on `rule.source` to apply source-specific condition logic.

### Challenge 2: State Management
**Problem:** Stateful logic (rate limits, timers, one-off pending flags) can't live in a CLI tool.
**Solution:** Persistent systemd daemon. All state in memory. CLI and collectors are stateless HTTP clients.

### Challenge 3: Configuration Complexity
**Problem:** Complex matching logic in JSON is error-prone.
**Solution:** Keep rule conditions simple (exact match + wildcard). Complex analysis belongs in the collector or sub-agent, not in the rule engine.

### Challenge 4: One-Off Reliability
**Problem:** One-off rules must not be lost if dispatch fails.
**Solution:** Mark-pending-then-finalize pattern (see §5). Rule only removed after confirmed successful dispatch.

## 13. Technical Stack
- **Runtime:** Node.js
- **Storage:** JSON files (`interrupt-rules.json`, `settings.json`)
- **Server:** Node.js `http` module (localhost only)
- **Delivery:** `openclaw system event` (message) / `openclaw agent --local` (subagent)
- **Service:** systemd user unit (`interrupt-service.service`)
