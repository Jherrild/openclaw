/**
 * lib/api.js — Programmatic API for obsidian-scribe
 * 
 * Import these functions directly instead of spawning child processes.
 * Used by: scribe.js CLI, memory provider, hooks.
 */
const fs = require('fs');
const path = require('path');
const {
  ensureDir, createBackup, runLint, triggerRagIndex,
  readContent, formatDiff, VAULT_ROOT, resolveVaultPath, log,
} = require('./operations');
const { updateMapping } = require('./sync-mapping');

/**
 * Create a new Obsidian note.
 * @param {string} relPath - Vault-relative path (e.g. "2-Areas/Finance/Budget.md")
 * @param {string} content - Note content (body text, frontmatter generated by linter)
 * @param {object} [opts]
 * @param {string[]} [opts.tags] - Tags to add
 * @param {string} [opts.fileId] - Supernote file ID for sync mapping
 * @param {boolean} [opts.skipLint] - Skip linting (for batch mode)
 * @returns {{ path: string, created: boolean }}
 */
function create(relPath, content, opts = {}) {
  const targetPath = resolveVaultPath(relPath);
  if (!targetPath) throw new Error(`Invalid path: ${relPath}`);

  if (fs.existsSync(targetPath)) {
    throw new Error(`File already exists: ${targetPath}. Use insert to append, or archive first.`);
  }

  ensureDir(targetPath);
  fs.writeFileSync(targetPath, content);
  log.success(`File written to: ${targetPath}`);

  try { updateMapping({ fileId: opts.fileId || null, localPath: targetPath }); }
  catch (e) { log.warn(`Sync mapping update failed: ${e.message}`); }

  runLint(targetPath, { tags: opts.tags, skip: opts.skipLint });
  triggerRagIndex(targetPath);

  return { path: targetPath, created: true };
}

/**
 * Insert content into a note (subsumes append).
 * @param {string} relOrAbsPath - Path to note
 * @param {string} content - Content to insert
 * @param {object} [opts]
 * @param {string} [opts.at='end'] - Insertion point: 'end', '## Heading', 'line:N'
 * @param {string[]} [opts.tags] - Tags to add
 * @param {boolean} [opts.skipLint] - Skip linting
 * @returns {{ path: string, insertedAt: string }}
 */
function insert(relOrAbsPath, content, opts = {}) {
  const targetPath = path.isAbsolute(relOrAbsPath) ? relOrAbsPath : resolveVaultPath(relOrAbsPath);
  if (!targetPath) throw new Error(`Invalid path: ${relOrAbsPath}`);

  const at = opts.at || 'end';
  let existing = '';
  if (fs.existsSync(targetPath)) {
    existing = fs.readFileSync(targetPath, 'utf-8');
  }

  let result;
  if (at === 'end') {
    // Append mode — smart newline handling
    let newContent = existing;
    if (newContent && !newContent.endsWith('\n')) newContent += '\n';
    if (newContent && !newContent.endsWith('\n\n')) newContent += '\n';
    newContent += content;
    result = newContent;
  } else if (at.startsWith('line:')) {
    const lineNum = parseInt(at.slice(5), 10);
    const lines = existing.split('\n');
    const idx = Math.min(Math.max(0, lineNum - 1), lines.length);
    lines.splice(idx, 0, content);
    result = lines.join('\n');
  } else {
    // Heading match — insert after the heading (before next same-or-higher level heading)
    const heading = at;
    const lines = existing.split('\n');
    const headingLevel = (heading.match(/^#+/) || [''])[0].length || 2;
    let insertIdx = -1;

    for (let i = 0; i < lines.length; i++) {
      if (lines[i].trim() === heading.trim()) {
        // Find the end of this section
        insertIdx = i + 1;
        for (let j = i + 1; j < lines.length; j++) {
          const hMatch = lines[j].match(/^(#+)\s/);
          if (hMatch && hMatch[1].length <= headingLevel) break;
          insertIdx = j + 1;
        }
        break;
      }
    }

    if (insertIdx === -1) {
      throw new Error(`Heading not found: "${heading}". Available headings: ${lines.filter(l => l.match(/^#+\s/)).map(l => l.trim()).join(', ')}`);
    }

    lines.splice(insertIdx, 0, '', content);
    result = lines.join('\n');
  }

  ensureDir(targetPath);
  fs.writeFileSync(targetPath, result);
  log.success(`Inserted at ${at}: ${targetPath}`);

  runLint(targetPath, { tags: opts.tags, skip: opts.skipLint });
  triggerRagIndex(targetPath);

  return { path: targetPath, insertedAt: at };
}

/**
 * Propose or apply an edit to a note.
 * @param {string} relOrAbsPath - Path to note
 * @param {string} find - Text to find
 * @param {string} replace - Replacement text
 * @param {object} [opts]
 * @param {boolean} [opts.apply=false] - If true, write changes. If false, return diff preview.
 * @param {number} [opts.context=2] - Context lines for diff
 * @param {string[]} [opts.tags] - Tags to add
 * @returns {{ path: string, diff: string, applied: boolean, matches: number }}
 */
function edit(relOrAbsPath, find, replace, opts = {}) {
  const targetPath = path.isAbsolute(relOrAbsPath) ? relOrAbsPath : resolveVaultPath(relOrAbsPath);
  if (!targetPath) throw new Error(`Invalid path: ${relOrAbsPath}`);
  if (!fs.existsSync(targetPath)) throw new Error(`File not found: ${targetPath}`);

  const original = fs.readFileSync(targetPath, 'utf-8');

  // Count matches
  const escapedFind = find.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const regex = new RegExp(escapedFind, 'g');
  const matches = (original.match(regex) || []).length;

  if (matches === 0) {
    throw new Error(`No matches found for: "${find.slice(0, 100)}${find.length > 100 ? '...' : ''}"`);
  }

  if (matches > 1) {
    throw new Error(`Ambiguous edit: "${find.slice(0, 60)}" matches ${matches} locations. Provide more context to narrow to a single match.`);
  }

  const modified = original.replace(find, replace);
  const diff = formatDiff(original, modified, opts.context || 2);

  if (!opts.apply) {
    return { path: targetPath, diff, applied: false, matches };
  }

  // Apply the edit
  createBackup(targetPath);
  fs.writeFileSync(targetPath, modified);
  log.success(`Edit applied to: ${targetPath}`);

  runLint(targetPath, { tags: opts.tags });
  triggerRagIndex(targetPath);

  return { path: targetPath, diff, applied: true, matches };
}

/**
 * Move a note (and linked documents) to a new location.
 * @param {string} source - Source path (vault-relative or absolute)
 * @param {string} target - Target path
 * @returns {{ from: string, to: string }}
 */
function move(source, target) {
  const sourcePath = resolveVaultPath(source);
  const targetPath = resolveVaultPath(target);
  if (!sourcePath || !targetPath) throw new Error('Invalid source or target path');
  if (!fs.existsSync(sourcePath)) throw new Error(`Source not found: ${sourcePath}`);

  // Handle collisions
  let finalDest = targetPath;
  if (fs.existsSync(finalDest)) {
    const ext = path.extname(finalDest);
    const name = path.basename(finalDest, ext);
    const dir = path.dirname(finalDest);
    let counter = 1;
    while (fs.existsSync(finalDest)) {
      finalDest = path.join(dir, `${name}-${counter}${ext}`);
      counter++;
    }
  }

  ensureDir(finalDest);
  fs.renameSync(sourcePath, finalDest);
  log.success(`Moved: ${sourcePath} -> ${finalDest}`);

  // Move linked documents
  if (path.extname(finalDest).toLowerCase() === '.md') {
    try {
      const content = fs.readFileSync(finalDest, 'utf-8');
      const linkRegex = /!\[\[documents\/([^\]]+)\]\]/g;
      let match;
      while ((match = linkRegex.exec(content)) !== null) {
        const docSource = path.join(path.dirname(sourcePath), 'documents', match[1]);
        const docTarget = path.join(path.dirname(finalDest), 'documents', match[1]);
        if (fs.existsSync(docSource)) {
          ensureDir(docTarget);
          fs.renameSync(docSource, docTarget);
          log.success(`Moved document: ${docSource} -> ${docTarget}`);
        }
      }
    } catch (e) { log.warn(`Document move scan failed: ${e.message}`); }
  }

  try { updateMapping({ fileId: null, localPath: finalDest, oldPath: sourcePath }); }
  catch (e) { log.warn(`Sync mapping update failed: ${e.message}`); }

  runLint(finalDest);
  triggerRagIndex(finalDest);

  return { from: sourcePath, to: finalDest };
}

/**
 * Archive a note to 4-Archive/.
 * @param {string} relOrAbsPath - Path to note
 * @returns {{ from: string, to: string }}
 */
function archive(relOrAbsPath) {
  const sourcePath = path.isAbsolute(relOrAbsPath) ? relOrAbsPath : resolveVaultPath(relOrAbsPath);
  if (!sourcePath) throw new Error(`Invalid path: ${relOrAbsPath}`);
  if (!fs.existsSync(sourcePath)) throw new Error(`File not found: ${sourcePath}`);

  const ARCHIVE_DIR = path.join(VAULT_ROOT, '4-Archive');
  const relativePath = path.relative(VAULT_ROOT, sourcePath);
  const parts = relativePath.split(path.sep);

  // Strip top-level PARA folder if present
  const paraRegex = /^[1-4]-/;
  const archiveRel = (parts.length > 1 && paraRegex.test(parts[0]))
    ? path.join(...parts.slice(1))
    : relativePath;

  let destPath = path.join(ARCHIVE_DIR, archiveRel);

  // Handle collisions
  if (fs.existsSync(destPath)) {
    const ext = path.extname(destPath);
    const name = path.basename(destPath, ext);
    const dir = path.dirname(destPath);
    let counter = 1;
    while (fs.existsSync(destPath)) {
      destPath = path.join(dir, `${name}-${counter}${ext}`);
      counter++;
    }
  }

  ensureDir(destPath);
  fs.renameSync(sourcePath, destPath);
  log.success(`Archived: ${sourcePath} -> ${destPath}`);

  runLint(destPath);
  triggerRagIndex(destPath);

  return { from: sourcePath, to: destPath };
}

/**
 * Read a file (markdown or PDF).
 * @param {string} relOrAbsPath - Path to file
 * @returns {{ path: string, content: string, frontmatter: object|null }}
 */
function read(relOrAbsPath) {
  const filePath = path.isAbsolute(relOrAbsPath) ? relOrAbsPath : resolveVaultPath(relOrAbsPath);
  if (!filePath || !fs.existsSync(filePath)) throw new Error(`File not found: ${relOrAbsPath}`);

  if (path.extname(filePath).toLowerCase() === '.pdf') {
    // Delegate to read_pdf.js logic
    const pdfParse = require('pdf-parse');
    const buffer = fs.readFileSync(filePath);
    // Note: pdf-parse is async but we keep API sync-compatible via require
    throw new Error('PDF reading requires async — use the CLI: node scribe.js read <path>');
  }

  const raw = fs.readFileSync(filePath, 'utf-8');
  const { parseFrontmatter } = require('./frontmatter');
  const { frontmatter, body } = parseFrontmatter(raw);

  return { path: filePath, content: body, frontmatter };
}

module.exports = { create, insert, edit, move, archive, read };
